MODULE main
VAR
  money: 0..50;
  moneyRequestsApproved: array 0..2 of boolean;
  client1: client (0, 1000, 5, moneyRequestsApproved);
  client2: client (1, 50, 15, moneyRequestsApproved);
  client3: client (2, 0, 2, moneyRequestsApproved);
  terminal1: terminal(client1, moneyRequestsApproved, money);
  terminal2: terminal(client2, moneyRequestsApproved, money);
  timer: 0..20;
ASSIGN
  init (money) := 0;
  init (timer) := 20;

  next(money) :=
      case
        timer = 0 & money < 40 : money + 10;
        terminal1.client.state = validRequest & money >= terminal1.client.moneyRequest : money - terminal1.client.moneyRequest;
        terminal2.client.state = validRequest & money >= terminal2.client.moneyRequest : money - terminal2.client.moneyRequest;
        TRUE : money;
      esac;

    next(timer) :=
      case
        timer > 0 : timer - 1;
        timer = 0 : 20;
        TRUE : timer;
      esac;

-- Клиент не может снять больше, чем у него есть на счету
LTLSPEC F !(client3.state = validRequest);
-- Клиент не может снять больше 10 рублей
LTLSPEC F !(client2.state = validRequest);
-- Клиент, которому не выдали деньги,  в конце концов их получит.
LTLSPEC G (client1.state = validRequest -> F client1.state = gotMoney);
-- Заблокированный клиент в конце концов сможет войти в систему
LTLSPEC F ((client2.state = blocked -> F client2.state = verifiedPass));
-- Заблокированный клиент не может войти в основное меню
LTLSPEC F !(client2.state = verifiedPass & client2.timer != -1);
-- Невозможно войти в основное меню, не введя правильную комбинацию ID-пароль
LTLSPEC G (client2.state = wait & client2.input = wrong_pass -> X (client2.state != verifiedPass));

MODULE terminal(client, moneyRequestsApproved, moneyAvailable)
ASSIGN
    next(moneyRequestsApproved[client.id]) :=
          case
              client.state = validRequest & moneyAvailable >= client.moneyRequest : TRUE;
              TRUE : moneyRequestsApproved[client.id];
          esac;

MODULE client(id, moneyAmount, moneyRequest, moneyRequestsApproved)
VAR
  failed_auth_attempts   : 0..3;
  input: {correct_pass, wrong_pass};
  state: {wait, blocked, verifiedPass, gotMoney, invalidRequest, validRequest};
  timer: -1..10;
ASSIGN
  init (state) := wait;
  init (timer) := -1;
  init (failed_auth_attempts) := 0;

  next(state) :=
  case
      timer <= 0 : wait;
      (state = wait | state = blocked & timer = 0) & input = correct_pass : verifiedPass;
      state = wait & input = wrong_pass & failed_auth_attempts = 3 : blocked;

      state = verifiedPass & (moneyAmount >= moneyRequest & moneyRequest <= 10) : validRequest;
      state = verifiedPass & (moneyAmount < moneyRequest | moneyRequest > 10)  : invalidRequest;
      state = validRequest & moneyRequestsApproved[id] = TRUE : gotMoney;
      state = validRequest & moneyRequestsApproved[id] = FALSE : blocked;
      TRUE : state;
  esac;

  next(failed_auth_attempts) := case
      state = wait & input = wrong_pass & failed_auth_attempts < 3: failed_auth_attempts + 1;
      timer = 0 : 0;
      TRUE : failed_auth_attempts;
    esac;

  next(timer) := case
    state = blocked & timer = - 1 : 10;
    state = blocked & timer >= 0 : timer - 1;
    state != blocked : - 1;
    TRUE : timer;
  esac;