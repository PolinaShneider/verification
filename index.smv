MODULE atm(machineId, initialAmount, cashIncrease)
VAR
    timeSinceCashIncrease : 0..cashIncreaseInterval;
    availableCash : 0..maxAvailableCash;
DEFINE
	cashIncreaseInterval := 20; -- regular time period between cash supply events
    maxAvailableCash := 100; -- you're able assigning any positive figure instead of the current one
    maxMachineId := 10; -- number of machines to provide ATM-specific service in the bank room (any positive number)
ASSIGN
	-- keep supply timer running
    init(timeSinceCashIncrease) := 0;
	next(timeSinceCashIncrease) := case
										timeSinceCashIncrease = cashIncreaseInterval: 0;
										TRUE: timeSinceCashIncrease + 1;
								   esac;

	-- update cash amount once supply event occurred
	init(availableCash) := initialAmount;
    next(availableCash) := case
								timeSinceCashIncrease = cashIncreaseInterval & (availableCash + cashIncrease = maxAvailableCash) : maxAvailableCash;
								timeSinceCashIncrease = cashIncreaseInterval & (availableCash + cashIncrease < maxAvailableCash) : availableCash + cashIncrease;
								TRUE: availableCash;
						   esac;

MODULE client(atm, clientId, clientPassword, balance, demand)
VAR
	state: {needForFreeAtm, login, failedToLogin, passedLogin, suspendedFromLogin, encounteredLimit, receivedCash};
    loginFailCounter : 0..loginCounterLimit; -- 3 straight failures result in 10 min suspension from attempted login
	timeSinceSuspension : 0..suspensionTimeLimit; -- 10 min as required
	cashDemand : 0..demand;	-- whatever positive figure to be an abstract withdraw target
DEFINE
    suspensionTimeLimit := 10;
	loginCounterLimit := 3;
	id := 10;
	password := 200;
	maxClientId := 1000;
ASSIGN
    -- manage client states to be consistent with his advance/failures throughout the session
    init(state) := needForFreeAtm;
	next(state) := case
						(state = passedLogin | state = encounteredLimit) & cashDemand <= balance & cashDemand <= 10 & cashDemand < atm.availableCash : receivedCash;
						(state = passedLogin | state = encounteredLimit) & (cashDemand > balance | cashDemand > 10 | cashDemand > atm.availableCash) : encounteredLimit;
						state = suspendedFromLogin & timeSinceSuspension = suspensionTimeLimit : login;
						state = failedToLogin & loginFailCounter = 2 : suspendedFromLogin;
						state = login & (clientId > maxClientId | id != clientId | password != clientPassword) : failedToLogin;
						state = login & clientId <= maxClientId & id = clientId & password = clientPassword : passedLogin;
						clientId <= atm.maxMachineId : login;
						TRUE : state;
				   esac;

    -- update login fail counter if client gets into the trouble
	init(loginFailCounter) := 0;
	next(loginFailCounter) := case
								loginFailCounter = loginCounterLimit : 0;
								TRUE : loginFailCounter + 1;
							  esac;

	-- update login suspension timer
	init(timeSinceSuspension) := 0;
	next(timeSinceSuspension) := case
									timeSinceSuspension = suspensionTimeLimit : 0;
									TRUE : timeSinceSuspension + 1;
								 esac;

	-- reevalaute demand if client faces issue due to ATM cash shortage, single-time withdraw limit or balance constraints
	init(cashDemand) := demand;
    next(cashDemand) := case
							state = passedLogin & cashDemand <= balance & cashDemand <= 10 & cashDemand <= atm.availableCash : 0;
							state = encounteredLimit & cashDemand > 10 & cashDemand <= balance & cashDemand <= atm.availableCash : cashDemand - 10;
                            state = encounteredLimit & cashDemand > balance : balance;
							TRUE : cashDemand;
					    esac;

MODULE main
VAR
    client1 : client(atm1, client1Id, client1Password, client1Balance, client1Demand);
	atm1 : atm(1, atm1InitialAmount, atm1CashIncrease);
DEFINE
	client1Id := 10; -- leave 10 to verify specs 3, 4, 5, 6 to 'true' outcome (specs 1, 2 to 'false') / set 1 to 9 rather than 10 if any spec should give evidence of 'true' result
	client1Password := 200; -- otherwise you may edit this password to monitor same consequences as in the case of ID change enforcements
    client1Balance := 50; -- make sure id = 10, then enable demand value to be one which is greater than balance - so spec 4 will expose the 'true' once process is over
    client1Demand := 55; -- to find counterexample particularly for spec 4, just set balance to be greater than the demand
    atm1InitialAmount := 10; -- should be positive value ahead of tool running
    atm1CashIncrease := 5; -- set id equal 10, then assign any positive value to this line variable - following that spec 6 will come out to 'true' assertion (conversely, leave 0 to have a counterexample for this case)

-- verify model in CTL style --
SPEC !AG AX (client1.state = suspendedFromLogin -> client1.state = passedLogin)
SPEC !AG (client1.state = login & (client1.id != client1Id | client1.password != client1Password) -> client1.state = passedLogin)
SPEC AF (client1.state = suspendedFromLogin -> client1.state = passedLogin)
SPEC !AG (client1Balance < client1Demand -> client1.state = receivedCash)
SPEC !AG (client1.state = passedLogin & (client1.state = login | client1.state = failedToLogin))
SPEC AG AF (client1.state = encounteredLimit -> client1.state = receivedCash);

-- verify model in LTL style --
LTLSPEC !G X (client1.state = suspendedFromLogin -> client1.state = passedLogin)
LTLSPEC !G (client1.state = login & (client1.id != client1Id | client1.password != client1Password) -> client1.state = passedLogin)
LTLSPEC F ((client1.state = suspendedFromLogin) -> (client1.state = passedLogin))
LTLSPEC !G (client1Balance < client1Demand -> client1.state = receivedCash)
LTLSPEC !G (client1.state = passedLogin & (client1.state = login | client1.state = failedToLogin))
LTLSPEC G F (client1.state = encounteredLimit -> client1.state = receivedCash)